--sprawdzamy numer sklepu!
select * from CONTRACTOR c where c.CONTRACTORID=1;

-- sprawdzamy czy możemy przeinsertować wszystkie rekordy

taskkill /f /im STSEstore.exe

CREATE TABLE PRODUCT_ AS
  (SELECT * FROM PRODUCT);
  
-- jeśli wyskoczy nam błąd szukamy uszkodzonego rekordu, tworzymy tabele pomocniczą  

CREATE TABLE PRODUCT_ AS
  (SELECT * FROM PRODUCT where rownum=1);

delete from PRODUCT_ where rownum=1

select count(*) from PRODUCT;
--317164

select count(*) from PRODUCT_;
--317164

-- i zaczynamy zabawę, metodą podziału na pół

insert into PRODUCT_ select * from PRODUCT p where p.PRODUCTID BETWEEN 1 AND 30000;

insert into PRODUCT_ select * from PRODUCT p where p.PRODUCTID BETWEEN 30001 AND 100000;

--- ...... i tak dalej

-- tworzymy CONTRAINTS i TRIGGERS PROCEDURE

call disableallconstraints();

call disablealltriggers();

truncate table PRODUCT;

insert into PRODUCT select * from PRODUCT_;

call enableallconstraints();

call enablealltriggers();

drop table PRODUCT_;

-- insert example

insert into PRODUCT_ (PRODUCTID, NAME, RECEIPTNAME, PRODUCTINDEX, HIERARCHYINDEX, PRODUCTLEVEL, ISPRODUCT, ISGROUP, PKWIU, ISBN, BRANDID, VATRATEID, MARGIN, TICKETTYPEID, INFO, ADDITIONALINFO, ACTIVITYSTATUS, LISTINGPERIODBEGIN, LISTINGPERIODEND, WIDTH, HEIGHT, DEPTH, VOLUME, PICTUREID, PACKAGEID, PACKAGEQUANTITY, WEIGHTED, FRESHNESSINDAYS, PRODUCTTYPE, PRODUCTCATEGORY, DISCOUNTABLE, ELECTRONICLABEL, MULTIPLEISSUES, MULTIPLEPRICES, SALEPRICEOPEN, TICKETABLE, REPAIRABLE, MINSTOCKINDAYS, OPTSTOCKINDAYS, MINSTOCKINSALEUNITS, MAXSTOCKINSALEUNITS, PROMOMINSTOCKINDAYS, PROMOOPTSTOCKINDAYS, PROMOMINSTOCKINSALEUNITS, PROMOMAXSTOCKINSALEUNITS, MAINSUPPLIERID, MEANCALCULATIONPERIOD, ORDERINGMETHOD, PALLETROUNDINGPROFILE, PALLETTYPE, SUPPLIERWAREHOUSEID, CREATORID, MODIFIERID, CREATIONTIME, LASTMODIFICATIONTIME, WEIGHTTYPE, MINIMUMCUSTOMERAGE, MINIMUMEMPLOYEEAGE, INCREASEDRISK, SELFSERVICENOTALLOWED, WEIGHTTOLERANCE, SECURITYWEIGHT, COUNTRYOFORIGIN, QUALITYCLASS, BASEPRODUCTMEASUREUNITID, SALEPRODUCTMEASUREUNITID, REFERENCEPRODUCTMEASUREUNITID, PRODUCTSUBTYPE, SUPPLYSOURCETYPE, REPLENISHMENTGROUP, MAINPLUCODEID, EXPIREDATEADJUSTMENT, ORDERINGMETHODPARAMS, STOCKMANAGEMENT, SUGGESTORDERINGUNTILDATE, LABELLAYOUTGROUP, MARKEDASBLOCKEDFORORDERDATE, FINANCIALTRANSACTIONTYPEID, AUDITBASEXPOSITION, AUDITADDEXPOSITIONTYPE, AUDITADDEXPOSITIONAMOUNT, DONTUSESELLERPOINTSCONVERSION, BASESELLERPOINTS, EXTRASELLERPOINTS, VISUALVERIFY, SALERATETYPE, NETWEIGHT, MIXINDICATOR, SUCCESSORID, MINIMALPRICE, WARRANTY, LASTLOCALMODIFICATIONTIME, PRODUCTSTATUSCODE, PRODUCTSTATUS, MRPTYPE, PURCHASEORDERGROUP, LAYOUTGROUPDESCRIPTION, MINEXPIRYDATE, EXPIRYDATE, EXPIRYUPDATEDATE, USEONLYASSUBCOMPONENTONCR, MULTIPACKQUANTITY, ISMULTIPACK, SCOQUANTITYREQUIRED, STATUSCODEUPDATEDATE, MINIMALEMPLOYEEPURCHASEPRICE, TAXEXEMPTIONREASONID, REQUIREDWHOLESALELICENSE)
values (16753535, 'MODNE KOLCZYKI', 'MODNE KOLCZYKI   \A', '3072158', '9004', 2, 1, 0, null, null, null, 13, 0, null, null, '<info><NonRefundable>0</NonRefundable></info>', 5, TO_DATE('2018/07/17', 'yyyy/mm/dd'), TO_DATE('9998/12/31', 'yyyy/mm/dd'), '', '', '', '', '', '', '', 0, null, 4, 1, 1, 0, 0, 0, 0, 0, 0, null, null, null, 9999999, null, null, null, null, null, null, null, 0, null, null, 2, 2, TO_DATE('2018/07/17', 'yyyy/mm/dd'), TO_DATE('2019/01/15', 'yyyy/mm/dd'), null, null, null, null, null, null, null, null, null, 20496937, 20496937, 20496937, null, 3, null, null, null, null, 0, null, null, null, null, null, null, null, 0, null, null, null, 0, null, 0, null, null, null, null, null, null, null, 'B01', '', '', '', '', 0, null, 0, 0, null, null, null, null);

-- daty zamieniamy na TO_DATE('2018/07/17', 'yyyy/mm/dd')
-- 'null' zamieniamy na ''

-- 3 tabele z ID czasami są to te same co PRODUCTID

select BASEPRODUCTMEASUREUNITID, SALEPRODUCTMEASUREUNITID, REFERENCEPRODUCTMEASUREUNITID from PRODUCT where PRODUCTID=16753535;

-- jeśli mamy osierocone rekordy, np ORA-02298

select PRODUCTID from PRODUCTMEASUREUNIT
where
PRODUCTID not in (select p.PRODUCTID from PRODUCT p);

-- raz było tak że PRODUCTMEASUREUNTID jest o oczko wyżej niż PRODUCTID w tabeli PRODUCTMEASUREUNIT  

update PRODUCTMEASUREUNIT set PRODUCTMEASUREUNITID=16753535 where PRODUCTID=16753535;

